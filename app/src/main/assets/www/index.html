<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8">
<title>Zoom + Pan</title>
<style>

    .plot {
    fill: rgba(250, 250, 255, 0.6);
    }
    .grid .tick {
    stroke: lightgrey;
    opacity: 0.7;
    }
    .grid path {
    stroke-width: 0;
    }
    .axis path, .axis line {
    fill: none;
    stroke: #000;
    shape-rendering: crispEdges;
    }
    .x.axis path {
    display: none;
    }
    .line {
    fill: none;
    stroke: steelblue;
    stroke-width: 1.5px;
    }

    .tick {
        font-size:10px;
    }

    .plot-title {
        padding-bottom: 10px;
        text-align: center;
        font-weight: bold;
    }

    .iv-axis {
        padding-top:100px;
        color:red;
    }

</style>
<body>
<div id="area"></div>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>

function showAndroidToast(toastmsg) {
    window.Android.showToast(toastmsg);
}

function appendPlot() {
    if(!appendingOrPrepending  || isBeginningOfData) {
        console.log("Update!! Append");
        window.Android.appendPlot();
        appendingOrPrepending = true;
        isBeginningOfData = false;
    }
}

function prependPlot() {
    if(!appendingOrPrepending || isEndOfData) {
        console.log("Update!! Prepend");
        window.Android.prependPlot();
        appendingOrPrepending = true;
        isEndOfData = false;
    }
}

function clear_chart() {
    d3.select("#area").select(".plot-title").remove();
    d3.select("#area").select("svg").remove();
}

function reachedEndOfData() {
    isEndOfData = true;
}

function reachedBeginningOfData() {
    isBeginningOfData = true;
}

var canAppend = true;
var canPrepend = true;
var appendingOrPrepending = false;
var isEndOfData = false;
var isBeginningOfData = false;
var data = [];
var line;
var chartBody;
var x;
var y;
var ymax;
var ymin;
var xmax;
var xmin;
var xAxis;
var yAxis;
var zoom;
var insertLinebreaks;
var clip;

function setTitle(title) {
    console.log("attempting to set title " + title);
    d3.select("#area")
       .append("div")
       .attr("class", "plot-title")
       .text(title);
}

function InitChart(screenWidth, screenHeight, dv, iv, dvName, ivName, plotTitle) {

var field = 'y';
var el = '#area';

setTitle(plotTitle);

margin = {
    top: 45,
    right: 20,
    bottom: 20
};

/* Larger margin for time curves y-axis */
if(ivName == "Time") {
    margin.left = 80;
}
else {
    margin.left = 50;
}
tickno = 8;

if(data.length > 5000) {
    for (var i = 0; i < dv.length; i++) {
        data.shift();
    }
}

for (var i = 0; i < dv.length; i++) {
    data.push({'x': dv[i], 'y': iv[i]});
    if(i == 0) {
        ymin = iv[0];
        ymax = iv[0];
        xmin = dv[0];
        xmax = dv[0];
    }
    else {
        if (ymin > iv[i]) {
            ymin = iv[i] + 1;
        }
        if (ymax < iv[i]) {
            ymax = iv[i];
        }
    }
}
console.log("first graph data length: " + data.length);

this.setData = function (dv, iv) {
    for (var i = 0; i < dv.length; i++) {
        data.push({'x': dv[i], 'y': iv[i]});
    }
}

width = window.innerWidth - 10 - margin.left - margin.right; //screenWidth
height = window.innerHeight - 50 - margin.top - margin.bottom; //screenHeight

xmax = d3.max(data,function(d){
    return d.x + 1;
});
xmin = d3.min(data,function(d) {
    return d.x - 1;
});

x = d3.scale.linear().domain([xmin,xmax]) /*d3.extent(data, function (d) {
return d.item;
}))*/
.range([0, width]);

y = d3.scale.linear()
    .domain([ymax,ymin])
    .range([height, 0]);

line = d3.svg.line()
    .interpolate("basis")
    .x(function (d) {
        return x(d.x); //x(d.item);
    })
    .y(function (d) {
        return y(d[field]);
    });

zoom = d3.behavior
    .zoom()
    //.x(x)
    .scaleExtent([-1, 2])
    .y(y)
    .on("zoom", zoomed);

svg = d3.select(el)
    .append("svg:svg")
    .attr('width', width + margin.left + margin.right)
    .attr('height', height + margin.top + margin.bottom)
    .append("svg:g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
    .call(zoom);

svg.append("svg:rect")
    .attr("width", width)
    .attr("height", height)
    .attr("class", "plot");

xAxis = d3.svg.axis()
    .scale(x)
    .orient("top")
    .ticks(tickno);

svg.append("svg:g")
    .attr("class", "x axis")
    .attr("transform", "translate(0, " + height + ")")
    .attr("transform", "translate(0)")
    .call(xAxis);

svg.append("svg:text")
    .attr("class", "text")
    .attr("x", width / 2 )
    .attr("y",  -30) //margin.top )
    .style("text-anchor", "middle")
    .text(dvName);

svg.append("svg:text")
    .classed({'text' : true, 'iv-axis' : true})
    .attr("transform", "rotate(-90)")
    .attr("x",  20) //-height / 2) //-margin.top - margin.bottom)
    .attr("y", -45) //.attr("y",  MARGINS.left)
    .attr("dy", "1em")
    .style("text-anchor", "middle")
    .text(ivName);

if(ivName == "Time") {
    yAxis = d3.svg.axis()
        .scale(y)
        .orient("left")
        .ticks(tickno)
        .tickFormat(function(d) {
                var format = d3.time.format("%x %X");
                return format(new Date(d))
            });
}
else {
    yAxis = d3.svg.axis()
        .scale(y)
        .orient("left")
        .ticks(tickno);
}

svg.append("g")
    .attr("class", "y axis")
    .call(yAxis);

svg.append("g")
    .attr("class", "x grid")
    .attr("transform", "translate(0," + height + ")")
    .call(make_x_axis()
    .tickSize(-height, 0, 0)
    .tickFormat(""));

svg.append("g")
    .attr("class", "y grid")
    .call(make_y_axis()
    .tickSize(-width, 0, 0)
    .tickFormat(""));

insertLinebreaks = function (d) {
    var el = d3.select(this);
    var words=d3.select(this).text().split(' ');
    el.text('');
    for (var i = 0; i < words.length; i++) {
        var tspan = el.append('tspan').text(words[i]);
        if (i > 0)
          tspan.attr('x', 0).attr('dy', '15');
    }
 };

svg.selectAll(".y.axis g text").each(insertLinebreaks);

clip = svg.append("svg:clipPath")
    .attr("id", "clip")
    .append("svg:rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("width", width)
    .attr("height", height);

chartBody = svg.append("g")
    .attr("clip-path", "url(#clip)");

chartBody.append("svg:path")
    .data([data])
    .attr("class", "line")
    .attr("d", line);
}

function zoomed() {
    svg.select(".x.axis").call(xAxis);
    svg.select(".y.axis").call(yAxis);
    svg.selectAll(".y.axis g text").each(insertLinebreaks);
    svg.select(".x.grid")
        .call(make_x_axis()
        .tickSize(-height, 0, 0)
        .tickFormat(""));
    svg.select(".y.grid")
        .call(make_y_axis()
        .tickSize(-width, 0, 0)
        .tickFormat(""));
    svg.select(".line")
        .attr("class", "line")
        .attr("d", line);
    svg.selectAll("dot").attr();

    /*console.log("y domain: " + y.domain());
    console.log("y x: " + y.domain()[0]);
    console.log("y y: " + y.domain()[1]);
    console.log("ymax: " + ymax);
    console.log("ymin: " + ymin);*/

    if(!appendingOrPrepending || isBeginningOfData || isEndOfData) {
        if (((y.domain()[0] - y.domain()[1]) * .85) + y.domain()[1] > ymax) {
            appendPlot();
        }
        else if (((y.domain()[0] - y.domain()[1]) * .15) + y.domain()[1] < ymin) {
            prependPlot();
        }
    }
}

var make_x_axis = function () {
    return d3.svg.axis()
        .scale(x)
        .orient("bottom")
        .ticks(tickno);
    };

var make_y_axis = function () {
    return d3.svg.axis()
        .scale(y)
        .orient("left")
        .ticks(tickno);
};

function resetDomainRanges() {
    /*Only scale the x axis */
    xmax = d3.max(data,function(d){
        return d.x + 1;
    });
    //User defined xmin
    xmin = d3.min(data,function(d) {
        return d.x - 1;
    });
    /*
    ymax = d3.max(data,function(d){
        return d.y + 1;
    });
    ymin = d3.min(data,function(d){
        return d.y - 1;
    });*/

    x.domain([xmin,xmax]);

    //Does not scale y axis
    //Does update the min and max for scrolling purposes
    for (var i = 0; i < data.length; i++) {
        if(i == 0) {
            ymin = data[i].y;
            ymax = data[i].y;
        }
        else {
            if (ymin > data[i].y) {
                ymin = data[i].y + 1;
            }
            if (ymax < data[i].y) {
                ymax = data[i].y;
            }
        }
    }
    /*
    console.log("new ymax: " + ymax);
    console.log("new ymin: " + ymin);*/
}

function updateAppendValues(dvVals, ivVals, maxPoints) {
    var startDataPos = data.length;
    var tooManyPoints = false;
    if(data.length >= maxPoints) {
        tooManyPoints = true;
    }
    for (var i = startDataPos; i < dvVals.length; i++) {
        if(tooManyPoints) {
            data.shift();
        }
        data.push({'x': dvVals[i], 'y': ivVals[i]});
    }

    resetDomainRanges();
    var updateTransition = svg.transition().duration(750);
    updateTransition.select(".x.axis").call(xAxis);
    updateTransition.select(".line").attr("d", line(data));
    appendingOrPrepending = false;
}

function updatePrependValues(dvVals, ivVals, maxPoints) {
    /* End position to copy is interval length */
    var endDataPos = (dvVals.length - data.length);
    var tooManyPoints = false;
    var tempData = [];
    if(data.length >= maxPoints) {
        tooManyPoints = true;
    }
    for (var i = 0; i < endDataPos; i++) {
        if(tooManyPoints) {
            data.pop();
        }
        data.unshift({'x': dvVals[(endDataPos-1)-i], 'y': ivVals[(endDataPos-1)-i]});
    }
    resetDomainRanges();
    var updateAxisTransition = svg.transition().duration(750);
    var updateTransition = svg.transition().duration(750);
    updateTransition.select(".x.axis").call(xAxis);
    updateTransition.select(".line").attr("d", line(data));
    appendingOrPrepending = false;
}
</script>
</body>
</html>
